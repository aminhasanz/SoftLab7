توضیحات بازآرایی‌ها:
Facade Pattern (کلاس Graph):

متدهای addNode و addEdge برای ساده کردن تعامل با گراف اضافه شد.
متد traverse برای اعمال الگوریتم پیمایش با استفاده از الگوی استراتژی اضافه شد.
State/Strategy Pattern:

کلاس‌های BFSTraversal و DijkstraTraversal ایجاد شدند و از طریق اینترفیس GraphTraversalStrategy عمل می‌کنند.
Separate Query from Modifier (کلاس Node):

متدهای getAvailableNeighbors و getAvailableWeightedNeighbors تغییر داده شدند تا تنها داده بازگردانند.
Self Encapsulated Field (کلاس Node):

فیلدهای visited و distance مستقیماً قابل دسترسی نیستند و از طریق getter و setter مدیریت می‌شوند.
Replace Magic Number (کلاس Node):

متد compareTo بر اساس distance بازنویسی شد.
Extract Method (کلاس Graph):
بخشی از منطق dijkstra به کلاس استراتژی منتقل شد.

# پاسخ سوالات
۱. کد تمیز: کدی که دارای چند ویژگی است:
الف) برای دیگر برنامه نویس ها واضح و قابل فهم است.
ب) کد تکراری اضافی ندارد
پ) حاوی حداقل تعداد کلاس ها و سایر قسمت های متحرک است.
ت) همه ی تست ها را پاس میکند.
ث) نگهداری آن آسان تر و ارزان تر است.

بدهی فنی: عملی که طی آن شما می توانید به طور موقت بدون نوشتن تست برای ویژگی های جدید سرعت خود را افزایش دهید، اما این کار به تدریج پیشرفت شما را هر روز کند می کند تا در نهایت با نوشتن تست ها بدهی را پرداخت کنید.

بوی بد: ویژگی هایی در کد منبع که احتمالا مشکلات عمیق تری را نشان می دهد.
دسته بندی مسائلی که ممکن است در طول زمان منجر به مشکل شود.
نشانه هایی که نشان می دهد کد تمیز و قابل نگهداری نیست.
نقض اصول اساسی طراحی.
پرچم های قرمز برای مسائل احتمالی که نیاز به توجه دارند.


۲. نفخ (Bloasters): کدها، روش ها و کلاس هایی هستند که به نسبت های عظیمی افزایش یافته اند که کار با آنها سخت است. معمولا این بوها بلافاصله ظاهر نمی شوند، بلکه با گذشت زمان با تکامل برنامه جمع می شوند (و به خصوص زمانی که هیچ تلاشی برای ریشه کن کردن آنها نمی کنیم)

Object-Orientation Abusers: همه این بوها کاربرد ناقص یا نادرست اصول برنامه نویسی شی گرا هستند.

Change Preventers: این بوها به این معنی است که اگر نیاز به تغییر چیزی در یک مکان از کد خود دارید، باید تغییرات زیادی را در مکان های دیگر نیز ایجاد کنید. در نتیجه توسعه برنامه بسیار پیچیده تر و گران تر می شود.

Dispensables: چیزی بی معنی و غیرضروری است که عدم وجود آن کد را تمیزتر، کارآمدتر و درک آن آسان تر می کند.

Couplers: تمام بوها در این گروه به اتصال بیش از حد بین کلاس ها کمک می کنند یا نشان می دهند که اگر کوپلینگ با تفویض اختیار بیش از حد جایگزین شود چه اتفاقی می افتد.


۳. Dispensables.
برای اجزایی که تقریبا بی فایده هستند Inline Class و برای زیرکلاس هایی با توابع کم Collapse Hierarchy
گاهی اوقات یک Lazy Class ایجاد میشود تا اهداف توسعه آینده را مشخص کند، در این مورد، سعی کنید تعادل بین وضوح و سادگی را در کد خود حفظ کنید.


۵. وظایف و عملکرد پلاگین formatter:
۱- قالب بندی خودکار کد:
پلاگین‌های formatter می‌توانند کد را با توجه به قوانین و استانداردهای مشخصی (مثل PEP 8 در پایتون) مرتب کنند. برای مثال:
- افزودن یا حذف فاصله‌ها و تورفتگی‌ها (Indentation).
- تنظیم فاصله میان پرانتزها، کروشه‌ها و آکولادها.
- شکستن خطوط طولانی به خطوط کوتاه‌تر.
۲- یکپارچگی سبک کدنویسی:
- هنگام کار در تیم‌های برنامه‌نویسی، سبک‌های مختلف کدنویسی می‌تواند منجر به ناسازگاری شود. استفاده از formatter این مشکل را رفع می‌کند و تمام کدها را مطابق یک سبک مشخص قالب‌بندی می‌کند.
۳- کاهش خطای انسانی:
- در زمان نوشتن کد، ممکن است خطاهایی ناشی از نامرتب بودن کد یا رعایت نکردن فاصله‌ها رخ دهد. formatter به‌طور خودکار این مشکلات را رفع می‌کند.
۴. افزایش خوانایی کد:
- کدی که مرتب باشد، به‌راحتی قابل‌خواندن است و به توسعه‌دهندگان کمک می‌کند تا سریع‌تر متوجه منطق و ساختار کد شوند.

رابطه پلاگین Formatter با بازآرایی کد (Code Refactoring)
- مرتب کردن کد پس از بازآرایی: وقتی که بخش هایی از کد تغییر میکند، ممکن است ساختار کلی آن بی نظم میشود. formatter میتواند این بی نظمی را رفع کند و کد را دوباره مرتب و خوانا کند.
- حفظ استانداردها در طول بازآرایی: با بازآرایی کد، ممکن است بخشی از سبک کدنویسی قبلی رعایت نشود. استفاده از formatter این اطمینان را می‌دهد که کد همچنان طبق استانداردهای تعیین‌شده قالب‌بندی می‌شود.
- تمرکز روی منطق به جای جزئیات ظاهری: استفاده از پلاگین‌های formatter باعث می‌شود که توسعه‌دهنده بیشتر روی منطق بازآرایی تمرکز کند و نگران ظاهر و قالب‌بندی کد نباشد.
